# QA Report for [OLAS](https://github.com/code-423n4/2024-05-olas) by K42
- I ensured these are all unique given the `4naly3er` report, and some that give more context to a couple mentioned in the `4naly3er`. And I did my best to make sure no issues were already mentioned in the other reports. 

## Summary
| Issue type | Count |
| --- | --- |
| List Of All Lows Covered |
| Low Severity Issues | 91 |
| Total Issues | 91 |
### Table of Contents
- [List Of All Lows](#list-of-all-lows-covered)
- [Summary](#summary)
- [Low Severity Issues](#low-severity-issues)

## List of All Lows Covered

1. ✅ **Lack of checks for duplicate nominees in `addNomineeEVM()` and `addNomineeNonEVM()`**
2. ✅ **Lack of checks for valid nominee in `voteForNomineeWeights()`**
3. ✅ **Lack of event emission for important state changes in `revokeRemovedNomineeVotingPower()`**
4. ✅ **Lack of input validation in `getNextAllowedVotingTimes()`**
5. ✅ **Lack of checks for duplicate service IDs in `stake()`**
6. ✅ **Inconsistency between `serviceIds` and `setServiceIds` in `unstake()`**
7. ✅ **Lack of access control for `checkpoint()` function**
8. ✅ **Missing event emission for important state changes in `_initialize()`**
9. ✅ **Lack of validation for `initPayload` in `createStakingInstance()`**
10. ✅ **Inconsistency between `verifyInstance()` and `verifyInstanceAndGetEmissionsAmount()`**
11. ✅ **Missing event emission for important state changes in `setInstanceStatus()`**
12. ✅ **Potential DOS in `verifyInstanceAndGetEmissionsAmount()`**
13. ✅ **Lack of checks for zero value in `receive()` function**
14. ✅ **Potential overflow in `receive()` function**
15. ✅ **Lack of function to withdraw excess funds**
16. ✅ **Lack of access control for `getImplementation()` function**
17. ✅ **Unclear error message in `ZeroImplementationAddress()` error**
18. ✅ **Lack of input validation in `fallback()` function**
19. ✅ **Missing event emission for implementation address change**
20. ✅ **Lack of checks for duplicate initialization in `initialize()` function**
21. ✅ **Missing checks for token allowance in `deposit()` function**
22. ✅ **Lack of checks for zero amount in `deposit()` function**
23. ✅ **Unused parameter in `_checkTokenStakingDeposit()` function**
24. ✅ **Lack of input validation for `_rewardsPerSecondLimit`, `_timeForEmissionsLimit`, and `_numServicesLimit` in the constructor**
25. ✅ **Missing checks for duplicate implementations in `setImplementationsStatuses()`**
26. ✅ **Inconsistent return value in `verifyInstance()` when the implementation is not whitelisted**
27. ✅ **Unused `instance` parameter in `getEmissionsAmountLimit()`**
28. ✅ **Lack of input validation for `_livenessRatio` in the constructor**
29. ✅ **Potential division by zero in `isRatioPass()`**
30. ✅ **Hardcoded array size in `getMultisigNonces()`**
31. ✅ **Lack of events for important state changes**
32. ✅ **Unclear error messages in `TokenTransferFailed` error**
33. ✅ **Lack of access control for `_receiveMessage()` function**
34. ✅ **Potential risk of reentrancy in `sendMessage()` and `sendMessageBatch()` functions**
35. ✅ **Missing input validation for zero addresses in `sendMessage()` and `sendMessageBatch()` functions**
36. ✅ **Lack of event emission for important state changes**
37. ✅ **Missing input validation in `processDataMaintenance()`**
38. ✅ **Unchecked return value of `IToken(olas).transfer()` in `migrate()`**
39. ✅ **Lack of input validation for `targets` and `stakingIncentives` arrays**
40. ✅ **Unused `bytes` parameter in `sendMessage()` and `sendMessageBatch()`**
41. ✅ **Unnecessary `immutable` keyword for `olas` variable**
42. ✅ **Inadequate validation of `bridgePayload` parameter**
43. ✅ **Potential underflow in `totalCost` calculation**
44. ✅ **Lack of event emission for important state changes**
45. ✅ **Missing access control for `receiveMessage()` function**
46. ✅ **Arithmetic overflow in `l1AliasedDepositProcessor` calculation**
47. ✅ **Missing event emission for receiving messages**
48. ✅ **Unchecked return value of `sendTxToL1()` function**
49. ✅ **Lack of access control for `receiveMessage()` function**
50. ✅ **Incompatible return value of `requireToPassMessage()` function**
51. ✅ **Inconsistent sequence assignment for token transfers and messages**
52. ✅ **Unchecked return value of `relayTokensAndCall()` function**
53. ✅ **Missing access control for `receiveMessage()` function**
54. ✅ **Incompatible return value of `requireToPassMessage()` function**
55. ✅ **Lack of event emission in `onTokenBridged()` function**
56. ✅ **Unchecked return value of `messageSender()` function**
57. ✅ **Lack of validation for `l2TargetDispenser` address**
58. ✅ **Unchecked return value of `depositERC20To()` function**
59. ✅ **Loss of precision in message cost calculation**
60. ✅ **Missing event emission for cross-chain message sending**
61. ✅ **Inconsistent event emission for cross-chain message posting**
62. ✅ **Lack of access control for `receiveMessage()` function**
63. ✅ **Loss of precision in message cost validation**
64. ✅ **Unchecked return value of `xDomainMessageSender()` function**
65. ✅ **Lack of event emission for token deposit**
66. ✅ **Missing access control for `_processMessageFromChild()` function**
67. ✅ **Potential inconsistency between `fxChildTunnel` and `l2TargetDispenser`**
68. ✅ **Unchecked return value of `depositFor()` function**
69. ✅ **Inconsistent event emission for cross-chain message posting**
70. ✅ **Missing event emission for important state changes in `_processMessageFromRoot()`**
71. ✅ **Unused `sender` parameter in `_processMessageFromRoot()`**
72. ✅ **Inconsistent handling of L2 target dispenser address**
73. ✅ **Lack of event emission for important state changes**
74. ✅ **Loss of precision in Wormhole chain ID conversion**
75. ✅ **Missing input validation in `receiveWormholeMessages()`**
76. ✅ **Lack of input validation for `bridgePayload` in `_sendMessage()`**
77. ✅ **Missing event emission for important state changes**
78. ✅ **Unnecessary storage of `l1SourceChainId` in the constructor**
79. ✅ **Potential rounding errors in incentive calculations**
80. ✅ **Inconsistency in updating `epochLen` and `veOLASThreshold`**
81. ✅ **Lack of checks for division by zero in `_trackServiceDonations()`**
82. ✅ **Lock of funds in `refundFromStaking()`**
83. ✅ **Inconsistency in `topUpEligible` calculation**
84. ✅ **Duplication of logic in `getSupplyCapForYear()` and `getInflationForYear()` functions**
85. ✅ **Magic numbers used in calculations**
86. ✅ **Lack of input validation for `numYears` parameter**
87. ✅ **Potential race condition in `claimStakingIncentives()`**
88. ✅ **Incorrect error message in `claimStakingIncentives()`**
89. ✅ **Lack of input validation in `setDepositProcessorChainIds()`**
90. ✅ **Inconsistency in `syncWithheldAmountMaintenance()`**
91. ✅ **Lack of access control for `retain()` function**

## Low Severity Issues

1. **[VoteWeighting.sol](https://github.com/code-423n4/2024-05-olas/blob/main/governance/contracts/VoteWeighting.sol): Lack of checks for duplicate nominees in `addNomineeEVM()` and `addNomineeNonEVM()`**
   - Description: The `addNomineeEVM()` and `addNomineeNonEVM()` functions do not check for duplicate nominees before adding them. This is low as could lead to unintended consequences and inconsistencies in the contract state.
   - Recommendation: You can implement a check to ensure that a nominee with the same `account` and `chainId` does not already exist, before adding a new nominee to resolve this.
   - Code Snippet:
     ```solidity
     function addNomineeEVM(address account, uint256 chainId) external {
         // ...
         Nominee memory nominee = Nominee(bytes32(uint256(uint160(account))), chainId);
 
         // Check for duplicate nominee
         bytes32 nomineeHash = keccak256(abi.encode(nominee));
         if (mapNomineeIds[nomineeHash] > 0) {
             revert NomineeAlreadyExists(nominee.account, nominee.chainId);
         }
 
         // Record nominee instance
         _addNominee(nominee);
     }
     ```
2. **[VoteWeighting.sol](https://github.com/code-423n4/2024-05-olas/blob/main/governance/contracts/VoteWeighting.sol): Lack of checks for valid nominee in `voteForNomineeWeights()`**
    - Description: The `voteForNomineeWeights()` function does not verify if the nominee being voted for is a valid nominee, for best practice it is suggested to implement a check for this. As this could lead to users allocating voting power to non-existent or invalid nominees.
    - Recommendation: Add a check to ensure that the nominee being voted for exists in the `mapNomineeIds` mapping before allowing the vote.
    - Code Snippet:
      ```solidity
      function voteForNomineeWeights(bytes32 account, uint256 chainId, uint256 weight) public {
          // ...
          // Check if the nominee exists
          Nominee memory nominee = Nominee(account, chainId);
          bytes32 nomineeHash = keccak256(abi.encode(nominee));
          if (mapNomineeIds[nomineeHash] == 0) {
              revert NomineeDoesNotExist(account, chainId);
          }
          // ...
      }
      ```
3. **[VoteWeighting.sol](https://github.com/code-423n4/2024-05-olas/blob/main/governance/contracts/VoteWeighting.sol): Lack of event emission for important state changes in `revokeRemovedNomineeVotingPower()`**
    - Description: The `revokeRemovedNomineeVotingPower()` function modifies important state vars such as `voteUserPower` and `voteUserSlopes` but does not emit any events to notify external entities about these changes.
    - Recommendation: For best practice emit an event to capture the relevant information whenever the voting power is revoked for a removed nominee.
    - Code Snippet:
      ```solidity
      function revokeRemovedNomineeVotingPower(bytes32 account, uint256 chainId) external {
          // ...
          // Update the voting power
          uint256 powerUsed = voteUserPower[msg.sender];
          powerUsed = powerUsed - oldSlope.power;
          voteUserPower[msg.sender] = powerUsed;
          delete voteUserSlopes[msg.sender][nomineeHash];
  
          // Emit an event to notify about the voting power revocation
          emit VotingPowerRevoked(msg.sender, account, chainId, oldSlope.power);
      }
      ```
4. **[VoteWeighting.sol](https://github.com/code-423n4/2024-05-olas/blob/main/governance/contracts/VoteWeighting.sol): Lack of input validation in `getNextAllowedVotingTimes()`**
    - Description: The `getNextAllowedVotingTimes()` function doesn't validate the input arrays `accounts`, `chainIds`, and `voters` to ensure they have the same length. This could lead to unexpected patterns if the arrays have different lengths.
    - Recommendation: Add a check to ensure that the `accounts`, `chainIds`, and `voters` arrays have the same length before processing them.
    - Code Snippet:
      ```solidity
      function getNextAllowedVotingTimes(
          bytes32[] memory accounts,
          uint256[] memory chainIds,
          address[] memory voters
      ) external view returns (uint256[] memory nextAllowedVotingTimes) {
          // Check array lengths
          if (accounts.length != chainIds.length || accounts.length != voters.length) {
              revert WrongArrayLength(accounts.length, chainIds.length);
          }
          // ...
      }
      ```


5. **[StakingBase.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingBase.sol): Lack of checks for duplicate service IDs in `stake()`**
   - Description: The `stake()` function does not check if the provided `serviceId` has already been staked. This could possibly lead to the same service being staked multiple times, causing inconsistencies in the contract state and reward calculations, for best practice implement a check.
   - Recommendation: Implement a check to ensure that a service with the given `serviceId` is not already staked before allowing a new staking operation.
   - Code Snippet:
     ```solidity
     function stake(uint256 serviceId) external {
         // ...
         // Check if the service is already staked
         if (mapServiceInfo[serviceId].tsStart > 0) {
             revert ServiceAlreadyStaked(serviceId);
         }
         // ...
     }
     ```
6. **[StakingBase.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingBase.sol): Inconsistency between `serviceIds` and `setServiceIds` in `unstake()`**
    - Description: In the `unstake()` function, if the `checkpoint()` call does not return `serviceIds`, the function allocates `serviceIds` using `getServiceIds()`. However, it does not update `setServiceIds` after removing the unstaked service. This can therefore lead to inconsistencies between `serviceIds` and `setServiceIds`.
    - Recommendation: It is best to ensure that `setServiceIds` is always updated when a service is unstaked, regardless of whether `serviceIds` is returned by the `checkpoint()` call or not.
    - Code Snippet:
      ```solidity
      function unstake(uint256 serviceId) external returns (uint256 reward) {
          // ...
          // Update the set of staked service Ids
          if (inSet) {
              setServiceIds[idx] = setServiceIds[setServiceIds.length - 1];
              setServiceIds.pop();
          } else {
              // Update setServiceIds even if serviceIds was not returned by checkpoint()
              for (uint256 i = 0; i < setServiceIds.length; i++) {
                  if (setServiceIds[i] == serviceId) {
                      setServiceIds[i] = setServiceIds[setServiceIds.length - 1];
                      setServiceIds.pop();
                      break;
                  }
              }
          }
          // ...
      }
      ```
7. **[StakingBase.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingBase.sol): Lack of access control for `checkpoint()` function**
    - Description: The `checkpoint()` function is public and can be called by any address. This could lead to potential DOS attacks if called frequently in correct pattern by malicious actors.
    - Recommendation: Consider adding access control mechanisms to better restrict access to the `checkpoint()` function to authorized addresses only, such as the contract owner or a specific role.
    - Code Snippet:
      ```solidity
      function checkpoint() public onlyAuthorized returns (
          uint256[] memory,
          uint256[][] memory,
          uint256[] memory,
          uint256[] memory,
          uint256[] memory evictServiceIds
      ) {
          // ...
      }
      ```
8. **[StakingBase.sol](https://github.com/code-423n4/2024-05- olas/blob/main/registries/contracts/staking/StakingBase.sol): Missing event emission for important state changes in `_initialize()`**
    - Description: The `_initialize()` function sets up the initial state of the contract by assigning values to various state variables. It does not emit any events to notify external entities about these initial values.
    - Recommendation: For best practice emit events for the important state variables initialized in the `_initialize()` function to enhance on chain transparency and allow off-chain monitoring of the contract's initial state.
    - Code Snippet:
      ```solidity
      function _initialize(
          StakingParams memory _stakingParams
      ) internal {
          // ...
          // Emit events for the initialized state variables
          emit MetadataHashSet(_stakingParams.metadataHash);
          emit MaxNumServicesSet(_stakingParams.maxNumServices);
          emit RewardsPerSecondSet(_stakingParams.rewardsPerSecond);
          // ...
      }
      ```

9. **[StakingFactory.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingFactory.sol): Lack of validation for `initPayload` in `createStakingInstance()`**
   - Description: The `createStakingInstance()` function checks if the length of `initPayload` is at least `SELECTOR_DATA_LENGTH`, but it doesn't validate the actual contents of the payload. This could lead to errors during the initialization of the staking instance.
   - Recommendation: Add more thorough validation of the `initPayload` to ensure it contains the correctly expected data and is properly formatted for the staking instance initialization.
   - Code Snippet:
     ```solidity
     function createStakingInstance(
         address implementation,
         bytes memory initPayload
     ) external returns (address payable instance) {
         // ...
         // The payload length must be at least of the a function selector size
         if (initPayload.length < SELECTOR_DATA_LENGTH) {
             revert IncorrectDataLength(initPayload.length, SELECTOR_DATA_LENGTH);
         }
         // Add more validation for initPayload contents
         // ...
     }
     ```
10. **[StakingFactory.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingFactory.sol): Inconsistency between `verifyInstance()` and `verifyInstanceAndGetEmissionsAmount()`**
   - Description: The `verifyInstance()` function checks if the instance is enabled and the implementation address is non-zero, while `verifyInstanceAndGetEmissionsAmount()` only calls `verifyInstance()` to determine the instance validity. This may lead to inconsistencies if `verifyInstance()` is updated without updating `verifyInstanceAndGetEmissionsAmount()`.
   - Recommendation: Add the same checks from `verifyInstance()` directly in `verifyInstanceAndGetEmissionsAmount()` to ensure consistency and avoid issues if `verifyInstance()` is modified.
   - Code Snippet:
     ```solidity
     function verifyInstanceAndGetEmissionsAmount(address instance) external view returns (uint256 amount) {
         // Get proxy instance params
         InstanceParams storage instanceParams = mapInstanceParams[instance];
         address implementation = instanceParams.implementation;
 
         // Check that the implementation corresponds to the proxy instance
         if (implementation == address(0)) {
             return 0;
         }
 
         // Check for the instance being active
         if (!instanceParams.isEnabled) {
             return 0;
         }
 
         // Provide additional checks, if needed
         address localVerifier = verifier;
         if (localVerifier != address(0) && !IStakingVerifier(localVerifier).verifyInstance(instance, implementation)) {
             return 0;
         }
 
         // Get the proxy instance emissions amount
         amount = IStaking(instance).emissionsAmount();
         // ...
     }
     ```
11. **[StakingFactory.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingFactory.sol): Missing event emission for important state changes in `setInstanceStatus()`**
   - Description: The `setInstanceStatus()` function modifies the `isEnabled` status of a staking instance but doesn't emit an event to notify external entities about the change.
   - Recommendation: Emit an event in `setInstanceStatus()` to capture the instance address and the updated `isEnabled` status for better transparency and monitoring.
   - Code Snippet:
     ```solidity
     function setInstanceStatus(address instance, bool isEnabled) external {
         // ...
         instanceParams.isEnabled = isEnabled;
 
         emit InstanceStatusChanged(instance, isEnabled);
     }
     ```
12. **[StakingFactory.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingFactory.sol): Potential DOS in `verifyInstanceAndGetEmissionsAmount()`**
   - Description: The `verifyInstanceAndGetEmissionsAmount()` function calls the `emissionsAmount()` function of the staking instance without gas (mana) limitations. If the `emissionsAmount()` function consumes a large amount of gas (mana), it might lead to a DOS situation where the `verifyInstanceAndGetEmissionsAmount()` function always reverts due to insufficient gas.
   - Recommendation: Add a gas (mana) limit to the `emissionsAmount()` function call using the `gasleft()` function to ensure that it does not consume all the available gas and cause a DOS.
   - Code Snippet:
     ```solidity
     function verifyInstanceAndGetEmissionsAmount(address instance) external view returns (uint256 amount) {
         // ...
         if (success) {
             // Get the proxy instance emissions amount with a gas limit
             uint256 gasLimit = gasleft() - 5000; // Adjust the gas limit as needed
             (bool success, bytes memory data) = instance.staticcall{gas: gasLimit}(abi.encodeWithSignature("emissionsAmount()"));
             if (success) {
                 amount = abi.decode(data, (uint256));
             }
             // ...
         }
     }
     ```

13. **[StakingNativeToken.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingNativeToken.sol): Lack of checks for zero value in `receive()` function**
   - Description: The `receive()` function does not check if the received `ETH` value (`msg.value`) is zero. This could lead to unnecessary state updates and event emissions even when no actual deposit is made.
   - Recommendation: Add a check to ensure that the received `ETH` value is greater than `0` before updating the balance and available rewards.
   - Code Snippet:
     ```solidity
     receive() external payable {
         if (msg.value == 0) {
             return;
         }
         // Add to the contract and available rewards balances
         uint256 newBalance = balance + msg.value;
         uint256 newAvailableRewards = availableRewards + msg.value;
         // ...
     }
     ```

14. **[StakingNativeToken.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingNativeToken.sol): Potential overflow in `receive()` function**
    - Description: The `receive()` function adds the received `ETH` value (`msg.value`) to the `balance` and `availableRewards` variables without checking for overflow. If the sum of the current balance and the received value exceeds the maximum value representable by `uint256`, an overflow will occur, leading to unintended impact.
    - Recommendation: Perform overflow checks before updating the `balance` and `availableRewards` variables to prevent overflow issues.
    - Code Snippet:
      ```solidity
      receive() external payable {
          // ...
          // Add to the contract and available rewards balances
          uint256 newBalance = balance + msg.value;
          uint256 newAvailableRewards = availableRewards + msg.value;
          
          // Check for overflow
          if (newBalance < balance || newAvailableRewards < availableRewards) {
              revert Overflow();
          }
          // ...
      }
      ```
15. **[StakingNativeToken.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingNativeToken.sol): Lack of function to withdraw excess funds**
    - Description: The contract does not provide a function to withdraw excess `ETH` sent to the contract accidentally or intentionally. Leading to funds being locked in the contract.
    - Recommendation: Implement a function that allows the contract owner or a designated role to withdraw excess `ETH` from the contract while ensuring that the available rewards and staked balances are not affected.
    - Code Snippet:
      ```solidity
      function withdrawExcessFunds(uint256 amount) external onlyOwner {
          uint256 excessFunds = balance - availableRewards - totalStaked;
          if (amount > excessFunds) {
              revert InsufficientExcessFunds();
          }
          balance -= amount;
          (bool success, ) = msg.sender.call{value: amount}("");
          if (!success) {
              revert TransferFailed(address(0), address(this), msg.sender, amount);
          }
      }
      ```

16. **[StakingProxy.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingProxy.sol): Lack of access control for `getImplementation()` function**
   - Description: The `getImplementation()` function is `external` and can be called by any `address`. While this function does not modify the contract state, it may not be intended for public access.
   - Recommendation: Add access control mechanisms to restrict the access to the `getImplementation()` function if it is meant to be accessed only by authorized addresses or contracts.
   - Code Snippet:
     ```solidity
     function getImplementation() external view onlyAuthorized returns (address implementation) {
         assembly {
             implementation := sload(SERVICE_STAKING_PROXY)
         }
     }
     ```
17. **[StakingProxy.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingProxy.sol): Unclear error message in `ZeroImplementationAddress()` error**
    - Description: The `ZeroImplementationAddress()` error is used when the provided implementation address in the constructor is the `0` address. However, the error message does not provide any additional context or information about the specific contract or function where the error occurred.
    - Recommendation: Add more context to the error message to make it clearer and more informative for users and developers.
    - Code Snippet:
      ```solidity
      /// @dev Zero implementation address provided in StakingProxy constructor.
      error ZeroImplementationAddress();
      ```
18. **[StakingProxy.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingProxy.sol): Lack of input validation in `fallback()` function**
    - Description: The `fallback()` function does not perform any input validation on the received `calldata` before delegating the call to the implementation contract. This may lead to unexpected patterns if the implementation contract does not properly handle the input.
    - Recommendation: Add input validation checks in the `fallback()` function to ensure that the received `calldata` is valid and meets the expected format before delegating the call to the implementation contract.
    - Code Snippet:
      ```solidity
      fallback() external payable {
          // Perform input validation on the received calldata
          // ...
          
          assembly {
              let implementation := sload(SERVICE_STAKING_PROXY)
              calldatacopy(0, 0, calldatasize())
              let success := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)
              returndatacopy(0, 0, returndatasize())
              if eq(success, 0) {
                  revert(0, returndatasize())
              }
              return(0, returndatasize())
          }
      }
      ```
19. **[StakingProxy.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingProxy.sol): Missing event emission for implementation address change**
    - Description: The `constructor` function sets the initial implementation address, but it does not emit an event to notify external entities about this important contract state change.
    - Recommendation: Emit an event in the `constructor` function to capture the initial implementation address for better transparency and monitoring.
    - Code Snippet:
      ```solidity
      constructor(address implementation) {
          // ...
          assembly {
              sstore(SERVICE_STAKING_PROXY, implementation)
          }
          emit ImplementationSet(implementation);
      }
      ```

20. **[StakingToken.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingToken.sol): Lack of checks for duplicate initialization in `initialize()` function**
   - Description: The `initialize()` function does not check if the contract has already been initialized.
   - Recommendation: For best practice, adding a check to ensure that the contract can only be initialized once, similar to the check in the `_initialize()` function of the `StakingBase` contract.
   - Code Snippet:
     ```solidity
     function initialize(
         StakingParams memory _stakingParams,
         address _serviceRegistryTokenUtility,
         address _stakingToken
     ) external {
         if (serviceRegistryTokenUtility != address(0)) {
             revert AlreadyInitialized();
         }
         // ...
     }
     ```
21. **[StakingToken.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingToken.sol): Missing checks for token allowance in `deposit()` function**
    - Description: The `deposit()` function does not check if the contract has sufficient allowance to transfer the specified amount of tokens from the caller. If the allowance is insufficient, the `safeTransferFrom()` call will revert.
    - Recommendation: Add a check to ensure that the contract has sufficient allowance before attempting the token transfer, or handle the case where the allowance is insufficient gracefully.
    - Code Snippet:
      ```solidity
      function deposit(uint256 amount) external {
          // Check if the contract has sufficient allowance
          if (IERC20(stakingToken).allowance(msg.sender, address(this)) < amount) {
              revert InsufficientAllowance();
          }
          // ...
      }
      ```
22. **[StakingToken.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingToken.sol): Lack of checks for `0` amount in `deposit()` function**
    - Description: The `deposit()` function does not check if the deposited amount is `0`. Allowing zero-value deposits may lead to unnecessary contract state updates and pointless event emissions.
    - Recommendation: Add a check to ensure that the deposited amount is  `> 0` before processing the deposit.
    - Code Snippet:
      ```solidity
      function deposit(uint256 amount) external {
          if (amount == 0) {
              revert InvalidDepositAmount();
          }
          // ...
      }
      ```
23. **[StakingToken.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingToken.sol): Unused parameter in `_checkTokenStakingDeposit()` function**
    - Description: The `_checkTokenStakingDeposit()` function has an unused parameter `stakingDeposit`. This parameter is not used within the function body and can be removed to improve code clarity.
    - Recommendation: Remove the unused `stakingDeposit` parameter from the `_checkTokenStakingDeposit()` function signature.
    - Code Snippet:
      ```solidity
      function _checkTokenStakingDeposit(uint256 serviceId, uint32[] memory serviceAgentIds) internal view override {
          // ...
      }
      ```

24. **[StakingVerifier.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingVerifier.sol): Lack of input validation for `_rewardsPerSecondLimit`, `_timeForEmissionsLimit`, and `_numServicesLimit` in the constructor**
   - Description: The constructor does not validate the upper bounds for `_rewardsPerSecondLimit`, `_timeForEmissionsLimit`, and `_numServicesLimit`. Providing excessively large values for these parameters could lead to an unnecessarily high `emissionsLimit`, which may not be intended.
   - Recommendation: Add upper bound checks for `_rewardsPerSecondLimit`, `_timeForEmissionsLimit`, and `_numServicesLimit` in the constructor to ensure they are within reasonable limits and prevent the consequences of not having the checks.
   - Code Snippet:
     ```solidity
     constructor(address _olas, uint256 _rewardsPerSecondLimit, uint256 _timeForEmissionsLimit,
         uint256 _numServicesLimit) {
         // ...
         if (_rewardsPerSecondLimit > MAX_REWARDS_PER_SECOND || 
             _timeForEmissionsLimit > MAX_TIME_FOR_EMISSIONS ||
             _numServicesLimit > MAX_NUM_SERVICES) {
             revert InvalidLimits();
         }
         // ...
     }
     ```
25. **[StakingVerifier.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingVerifier.sol): Missing checks for duplicate implementations in `setImplementationsStatuses()`**
   - Description: The `setImplementationsStatuses()` function does not check for duplicate implementation addresses in the `implementations` array. This could lead to redundant storage writes.
   - Recommendation: Add a check to ensure that each implementation address appears only once in the `implementations` array before updating their whitelisting statuses.
   - Code Snippet:
     ```solidity
     function setImplementationsStatuses(
         address[] memory implementations,
         bool[] memory statuses,
         bool setCheck
     ) external {
         // ...
         for (uint256 i = 0; i < implementations.length; ++i) {
             // Check for duplicate implementations
             for (uint256 j = i + 1; j < implementations.length; ++j) {
                 if (implementations[i] == implementations[j]) {
                     revert DuplicateImplementation(implementations[i]);
                 }
             }
             // ...
         }
         // ...
     }
     ```
26. **[StakingVerifier.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingVerifier.sol): Inconsistent return value in `verifyInstance()` when the implementation is not whitelisted**
   - Description: In the `verifyInstance()` function, when `implementationsCheck` is true and the implementation is not whitelisted, the function immediately returns `false`. It continues with further checks even if the implementation is not whitelisted, which may lead to inconsistent return values.
   - Recommendation: Restructure the `verifyInstance()` function to ensure consistent return values and avoid unnecessary checks when the implementation is not whitelisted.
   - Code Snippet:
     ```solidity
     function verifyInstance(address instance, address implementation) external view returns (bool) {
         if (implementationsCheck && !mapImplementations[implementation]) {
             return false;
         }
     
         // Check that instance is the contract when it is not checked against the implementation
         if (instance.code.length == 0) {
             return false;
         }
     
         // ...
     }
     ```
27. **[StakingVerifier.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingVerifier.sol): Unused `instance` parameter in `getEmissionsAmountLimit()`**
   - Description: The `getEmissionsAmountLimit()` function takes an `instance` parameter, but it is not used within the function body. This unused parameter causes confusion and makes the code less readable.
   - Recommendation: Remove the unused `instance` parameter from the `getEmissionsAmountLimit()` function signature to improve code clarity.
   - Code Snippet:
     ```solidity
     function getEmissionsAmountLimit() external view returns (uint256) {
         return emissionsLimit;
     }
     ```

28. **[StakingActivityChecker.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingActivityChecker.sol): Lack of input validation for `_livenessRatio` in the constructor**
   - Description: The constructor does not validate the upper bound for `_livenessRatio`. Providing an excessively large value for `_livenessRatio` could lead to unrealistic expectations for the liveness ratio and make it difficult for services to pass the activity check.
   - Recommendation: Add an upper bound check for `_livenessRatio` in the constructor to ensure it is within a reasonable range and prevent unintended consequences.
   - Code Snippet:
     ```solidity
     constructor(uint256 _livenessRatio) {
         // Check for zero value
         if (_livenessRatio == 0) {
             revert ZeroValue();
         }
         // Check for upper bound
         if (_livenessRatio > MAX_LIVENESS_RATIO) {
             revert InvalidLivenessRatio();
         }
         livenessRatio = _livenessRatio;
     }
     ```
29. **[StakingActivityChecker.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingActivityChecker.sol): Potential division by `0` in `isRatioPass()`**
   - Description: The `isRatioPass()` function performs a division operation `((curNonces[0] - lastNonces[0]) * 1e18) / ts` without checking if `ts` is zero. If `ts` is zero, this will result in a division by `0` error and cause the transaction to revert.
   - Recommendation: Add a check to ensure that `ts` is `> 0` before performing the division operation to avoid potential `/` by `0` errors.
   - Code Snippet:
     ```solidity
     function isRatioPass(
         uint256[] memory curNonces,
         uint256[] memory lastNonces,
         uint256 ts
     ) external view virtual returns (bool ratioPass) {
         // ...
         if (ts > 0 && curNonces[0] > lastNonces[0]) {
             uint256 ratio = ((curNonces[0] - lastNonces[0]) * 1e18) / ts;
             ratioPass = (ratio >= livenessRatio);
         }
     }
     ```
30. **[StakingActivityChecker.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingActivityChecker.sol): Hardcoded array size in `getMultisigNonces()`**
   - Description: The `getMultisigNonces()` function always returns an array of size 1, regardless of the actual number of nonces available for the given multisig address. This hardcoded array size may limit the flexibility and scalability of the contract if multiple nonces need to be supported in the future.
   - Recommendation: Making the array size dynamic `[]` based on the number of nonces available for the given multisig address. This can be achieved by querying the multisig contract for the number of nonces and allocating the array accordingly.
   - Code Snippet:
     ```solidity
     function getMultisigNonces(address multisig) external view virtual returns (uint256[] memory nonces) {
         uint256 numNonces = IMultisig(multisig).getNumNonces();
         nonces = new uint256[](numNonces);
         for (uint256 i = 0; i < numNonces; i++) {
             nonces[i] = IMultisig(multisig).getNonceAt(i);
         }
     }
     ```
31. **[StakingActivityChecker.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/staking/StakingActivityChecker.sol): Lack of events for important state changes**
   - Description: The contract does not emit any events when important state changes occur, such as when the liveness ratio is set in the constructor. Emitting events helps in tracking the contract's state changes and facilitates off-chain monitoring and analytics.
   - Recommendation: Emit events for important state changes, such as when the liveness ratio is set in the constructor, for improved transparency and enabled better monitoring.
   - Code Snippet:
     ```solidity
     constructor(uint256 _livenessRatio) {
         // ...
         livenessRatio = _livenessRatio;
         emit LivenessRatioSet(_livenessRatio);
     }
     ```


32. **[SafeTransferLib.sol](https://github.com/code-423n4/2024-05-olas/blob/main/registries/contracts/utils/SafeTransferLib.sol): Unclear error messages in `TokenTransferFailed` error**
   - Description: The `TokenTransferFailed` error is used to indicate the failure of a token transfer. However, the error message does not provide any specific details about the reason for the failure, making it difficult to diagnose and debug the issue.
   - Recommendation: Add more informative error messages to the `TokenTransferFailed` error, such as the specific error code or reason returned by the token contract. This can help in identifying and resolving transfer failures more effectively.
   - Code Snippet:
     ```solidity
     error TokenTransferFailed(address token, address from, address to, uint256 value, bytes reason);
     
     // ...
     
     if (!success) {
         revert TokenTransferFailed(token, from, to, amount, getRevertReason());
     }
     
     // ...
     
     function getRevertReason() internal pure returns (bytes memory reason) {
         if (returndatasize() > 0) {
             assembly {
                 reason := mload(0x40)
                 mstore(0x40, add(reason, returndatasize()))
                 returndatacopy(reason, 0, returndatasize())
             }
         }
     }
     ```

33. **[DefaultDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/DefaultDepositProcessorL1.sol): Lack of access control for `_receiveMessage()` function**
   - Description: The `_receiveMessage()` function is marked as `internal`, which means it can be called by any function within the contract or derived contracts. However, this function should only be callable by the authorized L1 message relayer to prevent unauthorized message processing.
   - Recommendation: Add access control to the `_receiveMessage()` function to ensure that only the authorized L1 message relayer can call it. This can be achieved by making the function `external` and adding a modifier to check the caller's address.
   - Code Snippet:
     ```solidity
     function receiveMessage(address l2Dispenser, bytes memory data) external onlyL1MessageRelayer {
         _receiveMessage(msg.sender, l2Dispenser, data);
     }
     
     modifier onlyL1MessageRelayer() {
         if (msg.sender != l1MessageRelayer) {
             revert UnauthorizedCaller(msg.sender);
         }
         _;
     }
     ```
34. **[DefaultDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/DefaultDepositProcessorL1.sol): Potential risk of reentrancy in `sendMessage()` and `sendMessageBatch()` functions**
   - Description: The `sendMessage()` and `sendMessageBatch()` functions transfer OLAS tokens to the L2 target dispenser via the `_sendMessage()` function. If the implementation of `_sendMessage()` in the derived contracts involves external calls or state changes before the token transfer, it could introduce a reentrancy vulnerability.
   - Recommendation: Apply the checks-effects-interactions pattern in the `sendMessage()` and `sendMessageBatch()` functions to prevent potential reentrancy attacks. Ensure that any state changes or external calls in the `_sendMessage()` function are performed after the token transfer.
   - Code Snippet:
     ```solidity
     function sendMessage(
         address target,
         uint256 stakingIncentive,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) external virtual payable {
         // Perform checks and state changes before the token transfer
         if (msg.sender != l1Dispenser) {
             revert ManagerOnly(l1Dispenser, msg.sender);
         }
         
         // Construct one-element arrays from targets and amounts
         address[] memory targets = new address[](1);
         targets[0] = target;
         uint256[] memory stakingIncentives = new uint256[](1);
         stakingIncentives[0] = stakingIncentive;
         
         // Increase the staking batch nonce
         stakingBatchNonce++;
         
         // Send the message to L2 and transfer the tokens
         uint256 sequence = _sendMessage(targets, stakingIncentives, bridgePayload, transferAmount);
         
         emit MessagePosted(sequence, targets, stakingIncentives, transferAmount);
     }
     ```
35. **[DefaultDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/DefaultDepositProcessorL1.sol): Missing input validation for zero addresses in `sendMessage()` and `sendMessageBatch()` functions**
   - Description: The `sendMessage()` and `sendMessageBatch()` functions do not validate if the `target` addresses are non-zero. Sending messages to the `0` address may lead to lost funds.
   - Recommendation: Add input validation to check if the `target` addresses are non-zero before sending the messages. Revert the transaction if any of the `target` addresses are the `0` address.
   - Code Snippet:
     ```solidity
     function sendMessage(
         address target,
         uint256 stakingIncentive,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) external virtual payable {
         // ...
         
         // Check for non-zero target address
         if (target == address(0)) {
             revert ZeroAddress();
         }
         
         // ...
     }
     
     function sendMessageBatch(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) external virtual payable {
         // ...
         
         // Check for non-zero target addresses
         for (uint256 i = 0; i < targets.length; i++) {
             if (targets[i] == address(0)) {
                 revert ZeroAddress();
             }
         }
         
         // ...
     }
     ```

36. **[DefaultTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/DefaultTargetDispenserL2.sol): Lack of event emission for important state changes**
   - Description: The contract modifies important state variables such as `withheldAmount`, `stakingBatchNonce`, and `paused` without emitting corresponding events. Emitting events for these state changes would enhance transparency and facilitate off-chain monitoring and analytics.
   - Recommendation: Emit events whenever critical state variables are modified, such as in the `_processData()` function when `withheldAmount` and `stakingBatchNonce` are updated, and in the `pause()` and `unpause()` functions when the `paused` state is changed.
   - Code Snippet:
     ```solidity
     function _processData(bytes memory data) internal {
         // ...
         if (localWithheldAmount > 0) {
             withheldAmount += localWithheldAmount;
             emit WithheldAmountUpdated(localWithheldAmount, withheldAmount);
         }
         // ...
         stakingBatchNonce = batchNonce + 1;
         emit StakingBatchNonceUpdated(stakingBatchNonce);
         // ...
     }
     
     function pause() external {
         // ...
         paused = 2;
         emit TargetDispenserPaused();
     }
     
     function unpause() external {
         // ...
         paused = 1;
         emit TargetDispenserUnpaused();
     }
     ```

37. **[DefaultTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/DefaultTargetDispenserL2.sol): Missing input validation in `processDataMaintenance()`**
   - Description: The `processDataMaintenance()` function allows the contract owner to manually process data that was not delivered from `L1`. However, there is no validation on the input `data` parameter to ensure that it is properly formatted and contains valid information. This may lead to negative consequences if malformed or malicious data is provided.
   - Recommendation: Implement input validation checks on the `data` parameter in the `processDataMaintenance()` function to ensure that it adheres to the expected format and contains valid information before processing it. Reject any data that fails the validation checks to maintain the integrity of the contract's state.
   - Code Snippet:
     ```solidity
     function processDataMaintenance(bytes memory data) external {
         // ...
         require(data.length >= MIN_DATA_LENGTH, "Invalid data length");
         // Perform additional validation checks on the data format and contents
         // ...
         _processData(data);
     }
     ```
38. **[DefaultTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/DefaultTargetDispenserL2.sol): Unchecked return value of `IToken(olas).transfer()` in `migrate()`**
   - Description: In the `migrate()` function, the contract transfers the `OLAS` token balance to the new `L2` target dispenser using `IToken(olas).transfer()`. However, the return value of the `transfer()` function is not checked, which could lead to silent failures if the transfer is unsuccessful.
   - Recommendation: Check the return value of the `IToken(olas).transfer()` function and revert the transaction if the return value is `false`, indicating a failed transfer. This ensures that the contract's state remains consistent and prevents any loss of funds.
   - Code Snippet:
     ```solidity
     function migrate(address newL2TargetDispenser) external {
         // ...
         if (amount > 0) {
             bool success = IToken(olas).transfer(newL2TargetDispenser, amount);
             require(success, "OLAS transfer failed");
         }
         // ...
     }
     ```

39. **[EthereumDepositProcessor.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/EthereumDepositProcessor.sol): Lack of input validation for `targets` and `stakingIncentives` arrays**
   - Description: The `_deposit()` function, which is called by `sendMessage()` and `sendMessageBatch()`, does not validate that the `targets` and `stakingIncentives` arrays have the same length. If the arrays have different lengths, it could lead to unexpected patterns or out-of-bounds access.
   - Recommendation: Add a check at the beginning of the `_deposit()` function to ensure that the `targets` and `stakingIncentives` arrays have the same length. Revert the transaction if the lengths are not equal to prevent any potential issues.
   - Code Snippet:
     ```solidity
     function _deposit(address[] memory targets, uint256[] memory stakingIncentives) internal {
         require(targets.length == stakingIncentives.length, "Array length mismatch");
         // ...
     }
     ```


40. **[EthereumDepositProcessor.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/EthereumDepositProcessor.sol): Unused `bytes` parameter in `sendMessage()` and `sendMessageBatch()`**
   - Description: The `sendMessage()` and `sendMessageBatch()` functions have a `bytes memory` parameter that is not used within the function body. This unused parameter adds unnecessary complexity to the function signature.
   - Recommendation: Remove the unused `bytes memory` parameter from the `sendMessage()` and `sendMessageBatch()` function signatures to improve code clarity and reduce confusion.
   - Code Snippet:
     ```solidity
     function sendMessage(address target, uint256 stakingIncentive, uint256) external {
         // ...
     }
     
     function sendMessageBatch(address[] memory targets, uint256[] memory stakingIncentives, uint256) external {
         // ...
     }
     ```

41. **[EthereumDepositProcessor.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/EthereumDepositProcessor.sol): Unnecessary `immutable` keyword for `olas` variable**
   - Description: The `olas` variable is declared as `immutable` twice in the contract. The second declaration is redundant therefore can be removed to improve code readability and avoid confusion.
   - Recommendation: Remove the second `immutable` keyword for the `olas` variable declaration.
   - Code Snippet:
     ```solidity
     // OLAS address
     address public immutable olas;
     // Tokenomics dispenser address
     address public immutable dispenser;
     // Staking proxy factory address
     address public immutable stakingFactory;
     // DAO timelock address
     address public immutable timelock;
     ```

42. **[ArbitrumDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/ArbitrumDepositProcessorL1.sol): Inadequate validation of `bridgePayload` parameter**
   - Description: The `_sendMessage()` function decodes the `bridgePayload` parameter to extract various values such as `refundAccount`, `gasPriceBid`, `maxSubmissionCostToken`, `gasLimitMessage`, and `maxSubmissionCostMessage`. However, there is no validation performed on these decoded values to ensure they are within acceptable ranges or meet specific requirements. This lack of validation could lead to security vulnerabilities if malicious or invalid values are provided in the `bridgePayload`.
   - Recommendation: Implement comprehensive validation checks on the decoded values from the `bridgePayload` parameter. Ensure that each value is within the expected range, does not exceed any predefined limits, and meets any other specific requirements. Revert the transaction if any of the validation checks fail.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         (address refundAccount, uint256 gasPriceBid, uint256 maxSubmissionCostToken, uint256 gasLimitMessage,
             uint256 maxSubmissionCostMessage) = abi.decode(bridgePayload, (address, uint256, uint256, uint256, uint256));
         
         // Validate refundAccount
         require(refundAccount != address(0), "Invalid refund account");
         
         // Validate gasPriceBid
         require(gasPriceBid >= MIN_GAS_PRICE_BID && gasPriceBid <= MAX_GAS_PRICE_BID, "Invalid gas price bid");
         
         // Validate maxSubmissionCostToken
         require(maxSubmissionCostToken >= MIN_SUBMISSION_COST_TOKEN && maxSubmissionCostToken <= MAX_SUBMISSION_COST_TOKEN, "Invalid max submission cost token");
         
         // Validate gasLimitMessage
         require(gasLimitMessage >= MIN_GAS_LIMIT_MESSAGE && gasLimitMessage <= MAX_GAS_LIMIT_MESSAGE, "Invalid gas limit message");
         
         // Validate maxSubmissionCostMessage
         require(maxSubmissionCostMessage >= MIN_SUBMISSION_COST_MESSAGE && maxSubmissionCostMessage <= MAX_SUBMISSION_COST_MESSAGE, "Invalid max submission cost message");
         
         // ...
     }
     ```

43. **[ArbitrumDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/ArbitrumDepositProcessorL1.sol): Potential underflow in `totalCost` calculation**
   - Description: In the `_sendMessage()` function, the `totalCost` variable is calculated by adding `cost[0]` and `cost[1]`. However, there is no check to ensure that the addition does not result in an underflow. If `cost[0]` or `cost[1]` is a large value close to `type(uint256).max`, the addition could wrap around and result in an unexpectedly small `totalCost` value.
   - Recommendation: Use the SafeMath library or perform overflow checks before calculating `totalCost` to ensure that the addition does not result in an underflow. Revert the transaction if an underflow is detected.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         uint256 totalCost;
         unchecked {
             totalCost = cost[0] + cost[1];
         }
         require(totalCost >= cost[0] && totalCost >= cost[1], "Total cost underflow");
         // ...
     }
     ```

44. **[ArbitrumDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/ArbitrumDepositProcessorL1.sol): Lack of event emission for important state changes**
   - Description: The `ArbitrumDepositProcessorL1` contract does not emit events for important state changes, such as setting the L2 target dispenser address or receiving messages from L2. Emitting events helps in tracking the contract's state changes and facilitates off-chain monitoring and analytics.
   - Recommendation: Emit events for important state changes, such as when the L2 target dispenser address is set using the `setL2TargetDispenser()` function inherited from the `DefaultDepositProcessorL1` contract, and when a message is received from L2 in the `receiveMessage()` function.
   - Code Snippet:
     ```solidity
     function setL2TargetDispenser(address l2Dispenser) external override {
         _setL2TargetDispenser(l2Dispenser);
         emit L2TargetDispenserSet(l2Dispenser);
     }
     
     function receiveMessage(bytes memory data) external {
         // ...
         _receiveMessage(l1MessageRelayer, l2Dispenser, data);
         emit MessageReceivedFromL2(l2Dispenser, data);
     }
     ```

45. **[ArbitrumDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/ArbitrumDepositProcessorL1.sol): Missing access control for `receiveMessage()` function**
   - Description: The `receiveMessage()` function is marked as `external`, allowing any address to call it. However, this function should only be callable by the authorized bridge contract to prevent unauthorized message processing.
   - Recommendation: Add access control to the `receiveMessage()` function to ensure that only the authorized bridge contract can call it. This can be achieved by adding a modifier or a require statement to check the caller's address against the `bridge` variable.
   - Code Snippet:
     ```solidity
     function receiveMessage(bytes memory data) external {
         require(msg.sender == bridge, "Unauthorized caller");
         // ...
     }
     ```

46. **[ArbitrumTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/ArbitrumTargetDispenserL2.sol): Arithmetic overflow in `l1AliasedDepositProcessor` calculation**
   - Description: In the constructor of the `ArbitrumTargetDispenserL2` contract, the `l1AliasedDepositProcessor` address is calculated by adding an offset to the `_l1DepositProcessor` address using unchecked arithmetic. However, there is no validation to ensure that the resulting address does not overflow and wrap around to a lower value.
   - Recommendation: Add a check to ensure that the calculated `l1AliasedDepositProcessor` address is greater than the `_l1DepositProcessor` address to prevent potential overflow. Revert the transaction if an overflow is detected.
   - Code Snippet:
     ```solidity
     constructor(
         address _olas,
         address _proxyFactory,
         address _l2MessageRelayer,
         address _l1DepositProcessor,
         uint256 _l1SourceChainId
     )
         DefaultTargetDispenserL2(_olas, _proxyFactory, _l2MessageRelayer, _l1DepositProcessor, _l1SourceChainId)
     {
         // Get the l1AliasedDepositProcessor based on _l1DepositProcessor
         uint160 offset = uint160(0x1111000000000000000000000000000000001111);
         unchecked {
             l1AliasedDepositProcessor = address(uint160(_l1DepositProcessor) + offset);
         }
         require(l1AliasedDepositProcessor > _l1DepositProcessor, "Invalid aliased address");
     }
     ```

47. **[ArbitrumTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/ArbitrumTargetDispenserL2.sol): Missing event emission for receiving messages**
   - Description: The `receiveMessage()` function processes messages received from the L1 deposit processor contract but does not emit any events to notify external entities about the received message and its details.
   - Recommendation: Emit an event in the `receiveMessage()` function to capture the relevant information about the received message, such as the sender address, message data, and any other pertinent details. This will enhance transparency and facilitate off-chain monitoring and analytics.
   - Code Snippet:
     ```solidity
     function receiveMessage(bytes memory data) external payable {
         // ...
         _receiveMessage(l2MessageRelayer, l1DepositProcessor, data);
         emit MessageReceived(msg.sender, data);
     }
     ```

48. **[ArbitrumTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/ArbitrumTargetDispenserL2.sol): Unchecked return value of `sendTxToL1()` function**
   - Description: In the `_sendMessage()` function, the contract sends a message to L1 using the `sendTxToL1()` function of the `IBridge` interface. However, the return value of `sendTxToL1()`, which represents the unique identifier for the L2-to-L1 transaction, is not checked for success or validity.
   - Recommendation: Check the return value of the `sendTxToL1()` function and handle any potential errors or invalid return values appropriately. This can help detect and handle any issues with the message sending process.
   - Code Snippet:
     ```solidity
     function _sendMessage(uint256 amount, bytes memory) internal override {
         // ...
         uint256 sequence = IBridge(l2MessageRelayer).sendTxToL1(l1DepositProcessor, data);
         require(sequence > 0, "Invalid message sequence");
         emit MessagePosted(sequence, msg.sender, l1DepositProcessor, amount);
     }
     ```

49. **[ArbitrumTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/ArbitrumTargetDispenserL2.sol): Lack of access control for `receiveMessage()` function**
   - Description: The `receiveMessage()` function is marked as `external`, allowing any address to call it. However, this function should only be callable by the authorized L1 deposit processor contract to prevent unauthorized message processing.
   - Recommendation: Add access control to the `receiveMessage()` function to ensure that only the authorized L1 deposit processor contract can call it. This can be achieved by adding a modifier or a require statement to check the caller's address against the `l1AliasedDepositProcessor` variable.
   - Code Snippet:
     ```solidity
     function receiveMessage(bytes memory data) external payable {
         require(msg.sender == l1AliasedDepositProcessor, "Unauthorized caller");
         // ...
     }
     ```


50. **[GnosisDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/GnosisDepositProcessorL1.sol): Incompatible return value of `requireToPassMessage()` function**
   - Description: The `_sendMessage()` function calls the `requireToPassMessage()` function of the `IBridge` interface to send a message to L2. However, the return value of `requireToPassMessage()` is of type `bytes32`, whereas the `sequence` variable is of type `uint256`. Directly assigning the `bytes32` value to `uint256` may lead to unexpected behavior or loss of information.
   - Recommendation: Convert the `bytes32` return value of `requireToPassMessage()` to `uint256` using an appropriate conversion method before assigning it to the `sequence` variable. Ensure that the conversion is safe and does not truncate or lose any significant information.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         if (transferAmount == 0) {
             // ...
             bytes32 iMsg = IBridge(l1MessageRelayer).requireToPassMessage(l2TargetDispenser, data, gasLimitMessage);
             sequence = uint256(iMsg);
         }
         // ...
     }
     ```

51. **[GnosisDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/GnosisDepositProcessorL1.sol): Inconsistent sequence assignment for token transfers and messages**
   - Description: In the `_sendMessage()` function, when `transferAmount` is greater than zero, the `sequence` variable is assigned the value of `stakingBatchNonce`. However, when `transferAmount` is zero and only a message is sent, the `sequence` variable is assigned the converted value of the `iMsg` returned by `requireToPassMessage()`. This inconsistency in sequence assignment may lead to difficulty in tracking and correlating token transfers and messages.
   - Recommendation: Use a consistent approach for assigning the `sequence` variable, regardless of whether tokens are transferred or only a message is sent. One option could be to always use the `stakingBatchNonce` value for the `sequence`, ensuring a consistent and predictable sequence numbering.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         if (transferAmount > 0) {
             // ...
             sequence = stakingBatchNonce;
         } else {
             // ...
             bytes32 iMsg = IBridge(l1MessageRelayer).requireToPassMessage(l2TargetDispenser, data, gasLimitMessage);
             sequence = stakingBatchNonce;
         }
         // ...
     }
     ```

52. **[GnosisDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/GnosisDepositProcessorL1.sol): Unchecked return value of `relayTokensAndCall()` function**
   - Description: In the `_sendMessage()` function, when `transferAmount` is `> 0`, the contract calls the `relayTokensAndCall()` function of the `IBridge` interface to transfer tokens and relay a message. However, the return value of `relayTokensAndCall()` is not checked for success or errors.
   - Recommendation: Check the return value or any error conditions returned by the `relayTokensAndCall()` function to ensure that the token transfer and message relay were successful. Handle any errors or failures appropriately, such as reverting the transaction or emitting an event to notify the users.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         if (transferAmount > 0) {
             // ...
             IToken(olas).approve(l1TokenRelayer, transferAmount);
             IBridge(l1TokenRelayer).relayTokensAndCall(olas, l2TargetDispenser, transferAmount, data);
             // Check the return value or any error conditions
             // ...
             sequence = stakingBatchNonce;
         }
         // ...
     }
     ```

53. **[GnosisDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/GnosisDepositProcessorL1.sol): Missing access control for `receiveMessage()` function**
   - Description: The `receiveMessage()` function is marked as `external`, allowing any address to call it. However, this function should only be callable by the authorized `AMB` bridge contract to prevent unauthorized message processing.
   - Recommendation: Add access control to the `receiveMessage()` function to ensure that only the authorized `AMB` bridge contract can call it. This can be achieved by adding a modifier or a require statement to check the caller's address against the `l1MessageRelayer` variable.
   - Code Snippet:
     ```solidity
     function receiveMessage(bytes memory data) external {
         require(msg.sender == l1MessageRelayer, "Unauthorized caller");
         // ...
     }
     ```


54. **[GnosisTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/GnosisTargetDispenserL2.sol): Incompatible return value of `requireToPassMessage()` function**
   - Description: The `_sendMessage()` function calls the `requireToPassMessage()` function of the `IBridge` interface to send a message to L1. However, the return value of `requireToPassMessage()` is of type `bytes32`, whereas the `MessagePosted` event expects a `uint256` value for the `sequence` parameter. Directly casting the `bytes32` value to `uint256` may lead to unexpected behavior or loss of information.
   - Recommendation: Convert the `bytes32` return value of `requireToPassMessage()` to `uint256` using an appropriate conversion method before emitting the `MessagePosted` event. Ensure that the conversion is safe and does not truncate or lose any significant information.
   - Code Snippet:
     ```solidity
     function _sendMessage(uint256 amount, bytes memory bridgePayload) internal override {
         // ...
         bytes32 iMsg = IBridge(l2MessageRelayer).requireToPassMessage(l1DepositProcessor, data, gasLimitMessage);
         uint256 sequence = uint256(iMsg);
         emit MessagePosted(sequence, msg.sender, l1DepositProcessor, amount);
     }
     ```

55. **[GnosisTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/GnosisTargetDispenserL2.sol): Lack of event emission in `onTokenBridged()` function**
   - Description: The `onTokenBridged()` function processes the data received together with the token transfer from L1. However, it does not emit any events to notify external entities about the token bridging and the associated data processing.
   - Recommendation: Emit an event in the `onTokenBridged()` function to capture relevant information such as the token address, amount, and the processed data. This will enhance transparency and facilitate monitoring and debugging of token bridging operations.
   - Code Snippet:
     ```solidity
     function onTokenBridged(address token, uint256 amount, bytes calldata data) external {
         // ...
         _receiveMessage(l2MessageRelayer, l1DepositProcessor, data);
         emit TokenBridged(token, amount, data);
     }
     ```

56. **[GnosisTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/GnosisTargetDispenserL2.sol): Unchecked return value of `messageSender()` function**
   - Description: In the `receiveMessage()` function, the contract retrieves the L1 deposit processor address using the `messageSender()` function of the `IBridge` interface. However, the return value of `messageSender()` is not checked for validity or errors.
   - Recommendation: Add a check to ensure that the returned value from `messageSender()` is a valid address and not the zero address. Handle any potential errors or invalid return values appropriately, such as reverting the transaction or emitting an event to notify the users.
   - Code Snippet:
     ```solidity
     function receiveMessage(bytes memory data) external {
         address processor = IBridge(l2MessageRelayer).messageSender();
         require(processor != address(0), "Invalid message sender");
         // ...
     }
     ```

57. **[OptimismDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/OptimismDepositProcessorL1.sol): Lack of validation for `l2TargetDispenser` address**
   - Description: In the `_sendMessage()` function, the `l2TargetDispenser` address is used as the target address for both the `depositERC20To()` and `sendMessage()` functions of the `IBridge` interface. However, there is no validation to ensure that the `l2TargetDispenser` address is a valid and trusted `address` on the L2 network.
   - Recommendation: Add a validation check to ensure that the `l2TargetDispenser` address is a valid and trusted address on the L2 network before using it in the `depositERC20To()` and `sendMessage()` functions. This can be done by maintaining a whitelist of trusted `L2` addresses or using a validation mechanism provided by the Optimism bridge.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         
         // Validate l2TargetDispenser address
         require(isValidL2Address(l2TargetDispenser), "Invalid L2 target dispenser address");
         
         // ...
         IBridge(l1TokenRelayer).depositERC20To(olas, olasL2, l2TargetDispenser, transferAmount,
             uint32(TOKEN_GAS_LIMIT), "");
         // ...
         IBridge(l1MessageRelayer).sendMessage{value: cost}(l2TargetDispenser, data, uint32(gasLimitMessage));
         // ...
     }
     ```

58. **[OptimismDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/OptimismDepositProcessorL1.sol): Unchecked return value of `depositERC20To()` function**
   - Description: In the `_sendMessage()` function, the `depositERC20To()` function of the `IBridge` interface is called to transfer OLAS tokens to the L2 network. However, the return value of `depositERC20To()` is not checked for success or any potential errors.
   - Recommendation: Check the return value or any error conditions returned by the `depositERC20To()` function to ensure that the token transfer was successful. Handle any errors or failures appropriately, such as reverting the transaction or emitting an event to notify the users.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         
         // Transfer OLAS to L2 staking dispenser contract across the bridge
         bool success = IBridge(l1TokenRelayer).depositERC20To(olas, olasL2, l2TargetDispenser, transferAmount,
             uint32(TOKEN_GAS_LIMIT), "");
         require(success, "OLAS transfer to L2 failed");
         
         // ...
     }
     ```

59. **[OptimismDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/OptimismDepositProcessorL1.sol): Loss of precision in message cost calculation**
   - Description: In the `_sendMessage()` function, the `cost` and `gasLimitMessage` values are decoded from the `bridgePayload` using `abi.decode()`. However, there is no check to ensure that the `cost` value is within a reasonable range and can be safely converted to the `msg.value` type without loss of precision, this may be intended but for best practice a check is suggested.
   - Recommendation: Add a validation check to ensure that the `cost` value is within a reasonable range and can be safely converted to the `msg.value` type without loss of precision. Consider using a safe math library or performing explicit range checks to prevent potential issues.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         
         // Decode cost related data
         (uint256 cost, uint256 gasLimitMessage) = abi.decode(bridgePayload, (uint256, uint256));
         
         // Validate cost range
         require(cost >= MIN_COST && cost <= MAX_COST, "Invalid message cost");
         
         // ...
     }
     ```

60. **[OptimismDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/OptimismDepositProcessorL1.sol): Missing event emission for cross-chain message sending**
   - Description: The `_sendMessage()` function sends a cross-chain message to the L2 network using the `sendMessage()` function of the `IBridge` interface. However, there is no event emitted to notify external entities about the message sending and its associated details.
   - Recommendation: Emit an event in the `_sendMessage()` function to capture relevant information such as the target address, message data, gas limit, and any other pertinent details. This will enhance transparency, and monitoring and debugging of cross-chain message sending.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory bridgePayload,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         
         // Send message to L2
         IBridge(l1MessageRelayer).sendMessage{value: cost}(l2TargetDispenser, data, uint32(gasLimitMessage));
         
         emit MessageSentToL2(l2TargetDispenser, data, gasLimitMessage, cost);
         
         // ...
     }
     ```


61. **[OptimismTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/OptimismTargetDispenserL2.sol): Inconsistent event emission for cross-chain message posting**
   - Description: In the `_sendMessage()` function, an event named `MessagePosted` is emitted after sending a cross-chain message to the `L1` deposit processor. However, the `sequence` parameter of the event is hardcoded to `0`, which may not accurately represent the actual message sequence or identifier.
   - Recommendation: Consider modifying the `MessagePosted` event to include a more meaningful and accurate representation of the message sequence or identifier. This could be done by returning the message hash or a unique identifier from the `sendMessage()` function and using that value in the event emission.
   - Code Snippet:
     ```solidity
     function _sendMessage(uint256 amount, bytes memory bridgePayload) internal override {
         // ...
         
         // Send the message to L1 deposit processor
         bytes32 messageHash = IBridge(l2MessageRelayer).sendMessage{value: cost}(l1DepositProcessor, data, uint32(gasLimitMessage));
         
         emit MessagePosted(uint256(messageHash), msg.sender, l1DepositProcessor, amount);
     }
     ```

62. **[OptimismTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/OptimismTargetDispenserL2.sol): Lack of access control for `receiveMessage()` function**
   - Description: The `receiveMessage()` function is marked as `external` and can be called by any `address`. However, this function should only be callable by the authorized `L2` message relayer contract to prevent unauthorized message processing and potential security vulnerabilities.
   - Recommendation: Implement access control mechanisms to restrict the access to the `receiveMessage()` function, ensuring that only the authorized L2 message relayer contract can call it. This can be achieved by adding a modifier or a require statement to check the caller's address against the `l2MessageRelayer` address.
   - Code Snippet:
     ```solidity
     function receiveMessage(bytes memory data) external payable {
         // Check that the caller is the authorized L2 message relayer
         require(msg.sender == l2MessageRelayer, "Unauthorized caller");
         
         // ...
     }
     ```

63. **[OptimismTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/OptimismTargetDispenserL2.sol): Loss of precision in message cost validation**
   - Description: In the `_sendMessage()` function, the `cost` value is extracted from the `bridgePayload` using `abi.decode()`. This value is then compared against `msg.value` to ensure that sufficient funds are provided to cover the message cost. But there is a potential loss of precision if `msg.value` is larger than `cost`, as the comparison may not accurately reflect the actual cost.
   - Recommendation: To prevent issues related to loss of precision, even though may be intended, consider using a safe comparison method, alternatively, you can convert both `msg.value` and `cost` to a common denomination or use a higher precision data type for the comparison.
   - Code Snippet:
     ```solidity
     function _sendMessage(uint256 amount, bytes memory bridgePayload) internal override {
         // ...
         
         // Extract bridge cost and gas limit from the bridge payload
         (uint256 cost, uint256 gasLimitMessage) = abi.decode(bridgePayload, (uint256, uint256));
         
         // Check that provided msg.value is enough to cover the cost
         require(msg.value >= cost, "Insufficient funds to cover message cost");
         
         // ...
     }
     ```

64. **[OptimismTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/OptimismTargetDispenserL2.sol): Unchecked return value of `xDomainMessageSender()` function**
   - Description: In the `receiveMessage()` function, the `xDomainMessageSender()` function is called to retrieve the address of the L1 deposit processor contract. The return value of this function is not checked for validity or errors, such as returning an unexpected or invalid `address`.
   - Recommendation: Add a validation check to ensure that the returned value from `xDomainMessageSender()` matches the expected L1 deposit processor address. If the returned address is invalid or does not match the expected value, the transaction should be reverted to prevent unauthorized message processing.
   - Code Snippet:
     ```solidity
     function receiveMessage(bytes memory data) external payable {
         // Check for the target dispenser address
         address l1Processor = IBridge(l2MessageRelayer).xDomainMessageSender();
         require(l1Processor == l1DepositProcessor, "Invalid L1 deposit processor address");
         
         // ...
     }
     ```

65. **[PolygonDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/PolygonDepositProcessorL1.sol): Lack of event emission for token deposit**
   - Description: In the `_sendMessage()` function, when `transferAmount` is greater than zero, OLAS tokens are deposited to the L2 target dispenser contract using the `depositFor()` function of the `IBridge` interface. However, there is no event emitted to notify external entities about the token deposit and its associated details.
   - Recommendation: Emit an event in the `_sendMessage()` function to capture relevant information such as the target dispenser address, token address, transfer amount, and any other pertinent details. This will enhance transparency.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         if (transferAmount > 0) {
             // ...
             IBridge(l1TokenRelayer).depositFor(l2TargetDispenser, olas, abi.encode(transferAmount));
             emit TokensDeposited(l2TargetDispenser, olas, transferAmount);
         }
         // ...
     }
     ```

66. **[PolygonDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/PolygonDepositProcessorL1.sol): Missing access control for `_processMessageFromChild()` function**
   - Description: The `_processMessageFromChild()` function is marked as `internal` and can be called by the `receiveMessage()` function inherited from the `FxBaseRootTunnel` contract. There is no access control mechanism in place to restrict the calling of this function to only authorized entities, such as the Polygon bridge contracts.
   - Recommendation: Implement access control measures to ensure that the `_processMessageFromChild()` function can only be called by authorized entities, such as the Polygon bridge contracts. This can be achieved by adding a modifier or a require statement to check the caller's address against a whitelist of allowed addresses.
   - Code Snippet:
     ```solidity
     function _processMessageFromChild(bytes memory data) internal override {
         require(msg.sender == fxRootTunnel, "Unauthorized caller");
         // ...
     }
     ```

67. **[PolygonDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/PolygonDepositProcessorL1.sol): Potential inconsistency between `fxChildTunnel` and `l2TargetDispenser`**
   - Description: The `setFxChildTunnel()` function is used to set the `fxChildTunnel` address, which represents the L2 target dispenser. The `setL2TargetDispenser()` function calls both `setFxChildTunnel()` and `_setL2TargetDispenser()`, potentially leading to inconsistency if the `l2Dispenser` address passed to these functions is different.
   - Recommendation: Ensure that the `l2Dispenser` address passed to `setFxChildTunnel()` and `_setL2TargetDispenser()` is always the same to maintain consistency between `fxChildTunnel` and `l2TargetDispenser`. Consider adding a check to validate that the addresses are identical before setting them.
   - Code Snippet:
     ```solidity
     function setL2TargetDispenser(address l2Dispenser) external override {
         require(l2Dispenser == fxChildTunnel, "Inconsistent L2 target dispenser address");
         setFxChildTunnel(l2Dispenser);
         _setL2TargetDispenser(l2Dispenser);
     }
     ```

68. **[PolygonDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/PolygonDepositProcessorL1.sol): Unchecked return value of `depositFor()` function**
   - Description: In the `_sendMessage()` function, when `transferAmount` is `> 0`, the `depositFor()` function of the `IBridge` interface is called to deposit `OLAS` tokens to the `L2` target dispenser contract. The return value of `depositFor()` is not checked for success or  errors.
   - Recommendation: Check the return value or any error conditions returned by the `depositFor()` function to ensure that the token deposit was successful. Handle any errors or failures appropriately, such as reverting the transaction or emitting an event to notify the users.
   - Code Snippet:
     ```solidity
     function _sendMessage(
         address[] memory targets,
         uint256[] memory stakingIncentives,
         bytes memory,
         uint256 transferAmount
     ) internal override returns (uint256 sequence) {
         // ...
         if (transferAmount > 0) {
             // ...
             bool success = IBridge(l1TokenRelayer).depositFor(l2TargetDispenser, olas, abi.encode(transferAmount));
             require(success, "Token deposit failed");
         }
         // ...
     }
     ```

69. **[PolygonTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/PolygonTargetDispenserL2.sol): Inconsistent event emission for cross-chain message posting**
   - Description: In the `_sendMessage()` function, an `event` named `MessagePosted` is emitted after sending a cross-chain message to the `L1` deposit processor. But the `sequence` parameter of the event is hardcoded to `0`, which may not accurately represent the actual message sequence or identifier.
   - Recommendation: Modify the `MessagePosted` `event` to include a more meaningful and accurate representation of the message sequence or identifier. This could be done by returning a unique identifier from the `_sendMessageToRoot()` function and using that value in the event emission.
   - Code Snippet:
     ```solidity
     function _sendMessage(uint256 amount, bytes memory) internal override {
         // ...
         uint256 sequence = _sendMessageToRoot(data);
         emit MessagePosted(sequence, msg.sender, l1DepositProcessor, amount);
     }
     ```

70. **[PolygonTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/PolygonTargetDispenserL2.sol): Missing event emission for important state changes in `_processMessageFromRoot()`**
   - Description: The `_processMessageFromRoot()` function processes messages received from the L1 Root Tunnel and calls the `_receiveMessage()` function to handle the received data. However, there is no event emitted to notify external entities about the received message and its processing.
   - Recommendation: Emit an event in the `_processMessageFromRoot()` function to capture relevant information such as the message sender, received data, and any other pertinent details. This will enhance transparency and facilitate monitoring and auditing of cross-chain message processing.
   - Code Snippet:
     ```solidity
     function _processMessageFromRoot(uint256, address sender, bytes memory data) internal override {
         // Process the data
         _receiveMessage(l2MessageRelayer, sender, data);
         emit MessageProcessed(sender, data);
     }
     ```

71. **[PolygonTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/PolygonTargetDispenserL2.sol): Unused `sender` parameter in `_processMessageFromRoot()`**
   - Description: The `_processMessageFromRoot()` function has a `sender` parameter that represents the `L1` message sender. This parameter is not used within the function body and is directly passed to the `_receiveMessage()` function without any validation or checks.
   - Recommendation: Add validation or checks on the `sender` parameter to ensure it meets the expected criteria before passing it to the `_receiveMessage()` function. If the `sender` parameter is not needed, consider removing it from the function signature to improve code clarity.
   - Code Snippet:
     ```solidity
     function _processMessageFromRoot(uint256, address sender, bytes memory data) internal override {
         // Validate the sender address
         require(sender == expectedSender, "Invalid message sender");
         // Process the data
         _receiveMessage(l2MessageRelayer, sender, data);
     }
     ```

72. **[WormholeDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/WormholeDepositProcessorL1.sol): Inconsistent handling of L2 target dispenser address**
   - Description: The `setL2TargetDispenser()` function updates the L2 target dispenser address by calling both `setRegisteredSender()` and `_setL2TargetDispenser()`. The `receiveWormholeMessages()` function retrieves the `L2` target dispenser address directly from the `sourceAddress` parameter using `address(uint160(uint256(sourceAddress)))`. This inconsistency in handling the `L2` target dispenser address may lead to unexpected patterns if the address set by `setL2TargetDispenser()` does not match the address derived from `sourceAddress`.
   - Recommendation: Ensure that the `L2` target dispenser address is consistently handled throughout the contract. Use the same method to derive or retrieve the `L2` target dispenser address in both the `setL2TargetDispenser()` and `receiveWormholeMessages()` functions. Additionally, add validation checks to ensure that the address set by `setL2TargetDispenser()` matches the expected format and value.
   - Code Snippet:
     ```solidity
     function receiveWormholeMessages(
         bytes memory data,
         bytes[] memory,
         bytes32 sourceAddress,
         uint16 sourceChain,
         bytes32 deliveryHash
     ) external {
         // ...
         address l2Dispenser = getRegisteredSender(sourceChain);
         require(l2Dispenser != address(0), "Invalid L2 target dispenser address");
         // ...
     }
     
     function setL2TargetDispenser(address l2Dispenser) external override {
         require(l2Dispenser != address(0), "Invalid L2 target dispenser address");
         bytes32 senderBytes = bytes32(uint256(uint160(l2Dispenser)));
         setRegisteredSender(uint16(wormholeTargetChainId), senderBytes);
         _setL2TargetDispenser(l2Dispenser);
     }
     ```

73. **[WormholeDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/WormholeDepositProcessorL1.sol): Lack of event emission for important state changes**
   - Description: The `WormholeDepositProcessorL1` contract does not emit events for important state changes, such as setting the L2 target dispenser address using the `setL2TargetDispenser()` function or processing messages received from L2 in the `receiveWormholeMessages()` function. Emitting events helps in tracking the contract's state changes and facilitates off-chain monitoring and analytics.
   - Recommendation: Consider emitting events for important state changes, such as when the L2 target dispenser address is set or when messages are received and processed from L2. This will enhance transparency.
   - Code Snippet:
     ```solidity
     function setL2TargetDispenser(address l2Dispenser) external override {
         // ...
         emit L2TargetDispenserSet(l2Dispenser);
     }
     
     function receiveWormholeMessages(
         bytes memory data,
         bytes[] memory,
         bytes32 sourceAddress,
         uint16 sourceChain,
         bytes32 deliveryHash
     ) external {
         // ...
         emit MessageReceivedFromL2(l2Dispenser, data, deliveryHash);
     }
     ```

74. **[WormholeDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/WormholeDepositProcessorL1.sol): Loss of precision in Wormhole chain ID conversion**
   - Description: The `wormholeTargetChainId` is stored as a `uint256` value in the contract, but it is cast to `uint16` when used in the `sendTokenWithPayloadToEvm()` function. This conversion may result in a loss of precision if the `wormholeTargetChainId` value is `>` `type(uint16).max`, although may be intended it is best to add a check.
   - Recommendation: Ensure that the `wormholeTargetChainId` value is within the valid range of `uint16` to avoid any potential loss of precision. Consider adding a validation check in the constructor to enforce this constraint.
   - Code Snippet:
     ```solidity
     constructor(
         // ...
         uint256 _wormholeTargetChainId
     )
         // ...
     {
         // ...
         require(_wormholeTargetChainId <= type(uint16).max, "Invalid Wormhole target chain ID");
         wormholeTargetChainId = _wormholeTargetChainId;
     }
     ```

75. **[WormholeDepositProcessorL1.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/WormholeDepositProcessorL1.sol): Missing input validation in `receiveWormholeMessages()`**
   - Description: The `receiveWormholeMessages()` function does not perform any input validation on the `data` parameter before passing it to the `_receiveMessage()` function. This could potentially lead to security issues if the `data` parameter is malformed or contains invalid data.
   - Recommendation: Add input validation checks on the `data` parameter in the `receiveWormholeMessages()` function to ensure that it adheres to the expected format and contains valid data. Reject any messages that fail the validation checks to maintain the integrity and security of the contract.
   - Code Snippet:
     ```solidity
     function receiveWormholeMessages(
         bytes memory data,
         bytes[] memory,
         bytes32 sourceAddress,
         uint16 sourceChain,
         bytes32 deliveryHash
     ) external {
         // ...
         require(data.length >= MIN_DATA_LENGTH, "Invalid data length");
         // Perform additional validation checks on the data format and contents
         // ...
         _receiveMessage(msg.sender, l2Dispenser, data);
     }
     ```

76. **[WormholeTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/WormholeTargetDispenserL2.sol): Lack of input validation for `bridgePayload` in `_sendMessage()`**
   - Description: The `_sendMessage()` function decodes the `bridgePayload` to extract `refundAccount` and `gasLimitMessage` without validating the contents of `bridgePayload`. If the `bridgePayload` is malformed or does not contain the expected data, it could lead to unexpected patterns or errors.
   - Recommendation: Add input validation checks for the `bridgePayload` parameter to ensure it has the correct length and contains valid data before decoding. Consider using a custom error or reverting with a descriptive error message if the validation fails.
   - Code Snippet:
     ```solidity
     function _sendMessage(uint256 amount, bytes memory bridgePayload) internal override {
         // Check for the bridge payload length
         if (bridgePayload.length != BRIDGE_PAYLOAD_LENGTH) {
             revert IncorrectDataLength(BRIDGE_PAYLOAD_LENGTH, bridgePayload.length);
         }
         
         // Validate the contents of bridgePayload
         // For example, check if refundAccount is a valid address and gasLimitMessage is within an acceptable range
         // If validation fails, revert with a descriptive error message
         // ...
         
         // Extract refundAccount and gasLimitMessage from bridgePayload
         (address refundAccount, uint256 gasLimitMessage) = abi.decode(bridgePayload, (address, uint256));
         // ...
     }
     ```

77. **[WormholeTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/WormholeTargetDispenserL2.sol): Missing event emission for important state changes**
   - Description: The `WormholeTargetDispenserL2` contract does not emit events for important state changes, such as when a message is received and processed in the `receivePayloadAndTokens()` function. Emitting events helps in tracking the contract's state changes and facilitates off-chain monitoring and analytics.
   - Recommendation: Emit events for important state changes, such as when a message is received and processed successfully or when an error occurs. To enable better monitoring of the contract.
   - Code Snippet:
     ```solidity
     function receivePayloadAndTokens(
         bytes memory data,
         TokenReceived[] memory receivedTokens,
         bytes32 sourceProcessor,
         uint16 sourceChainId,
         bytes32 deliveryHash
     ) internal override {
         // ...
         _receiveMessage(msg.sender, processor, data);
         emit MessageProcessed(processor, data, deliveryHash);
     }
     ```

78. **[WormholeTargetDispenserL2.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/staking/WormholeTargetDispenserL2.sol): Unnecessary storage of `l1SourceChainId` in the constructor**
   - Description: In the constructor of the `WormholeTargetDispenserL2` contract, the `l1SourceChainId` parameter is stored in the contract's storage using `l1SourceChainId = _l1SourceChainId`. However, the `l1SourceChainId` is already passed to the `DefaultTargetDispenserL2` constructor, which assigns it to the `l1SourceChainId` state variable. Storing the same value twice is unnecessary and increases the contract's deployment cost.
   - Recommendation: Remove the redundant assignment of `l1SourceChainId` in the constructor of the `WormholeTargetDispenserL2` contract since it is already handled by the `DefaultTargetDispenserL2` constructor.
   - Code Snippet:
     ```solidity
     constructor(
         // ...
     )
         DefaultTargetDispenserL2(_olas, _proxyFactory, _l2MessageRelayer, _l1DepositProcessor, _l1SourceChainId)
         TokenBase(_l2MessageRelayer, _l2TokenRelayer, _wormholeCore)
     {
         // ...
         // Remove the redundant assignment of l1SourceChainId
         // l1SourceChainId = _l1SourceChainId;
     }
     ```

79. **[Tokenomics.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Tokenomics.sol): Potential rounding errors in incentive calculations**
   - Description: In the `checkpoint()` function, the calculation of incentives involves division operations with integer values. This can lead to rounding errors and loss of precision, especially when dealing with large numbers or small fractions, although it may be intended, mitigation is still good practice.
   - Recommendation: Perform the calculations using higher precision to minimize rounding errors. Alternatively, you can use a different approach, such as distributing the incentives proportionally based on the relative weights of each component/agent.
   - Code Snippet:
     ```solidity
     incentives[1] = (incentives[0] * tp.epochPoint.rewardTreasuryFraction) / 100;
     incentives[2] = (incentives[0] * tp.unitPoints[0].rewardUnitFraction) / 100;
     incentives[3] = (incentives[0] * tp.unitPoints[1].rewardUnitFraction) / 100;
     ```

80. **[Tokenomics.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Tokenomics.sol): Inconsistency in updating `epochLen` and `veOLASThreshold`**
   - Description: In the `checkpoint()` function, the `epochLen` and `veOLASThreshold` values are updated based on the `nextEpochLen` and `nextVeOLASThreshold` values, respectively. However, there is no check to ensure that these values are within the allowed range before updating them. This could lead to inconsistent or even invalid values being set.
   - Recommendation: Add validation checks to ensure that the `nextEpochLen` and `nextVeOLASThreshold` values are within the allowed range before updating `epochLen` and `veOLASThreshold`. If the values are invalid, consider reverting the transaction or using default values instead.
   - Code Snippet:
     ```solidity
     if (nextEpochLen > 0) {
         curEpochLen = nextEpochLen;
         epochLen = uint32(curEpochLen);
         nextEpochLen = 0;
     }
     
     if (nextVeOLASThreshold > 0) {
         veOLASThreshold = nextVeOLASThreshold;
         nextVeOLASThreshold = 0;
     }
     ```

81. **[Tokenomics.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Tokenomics.sol): Lack of checks for `/ 0` in `_trackServiceDonations()`**
   - Description: In the `_trackServiceDonations()` function, the `amount` variable is calculated by dividing `amounts[i]` by `numServiceUnits`. However, there is no check to ensure that `numServiceUnits` is not `0` before performing the `/`. If `numServiceUnits` is `0`, it will result in a `/ 0` error.
   - Recommendation: Add a check to ensure that `numServiceUnits` is `> 0` before performing the `/`. If `numServiceUnits` is `0`, handle the case appropriately, such as skipping the iteration or returning an error.
   - Code Snippet:
     ```solidity
     uint96 amount = uint96(amounts[i] / numServiceUnits);
     ```

82. **[Tokenomics.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Tokenomics.sol): Lock of funds in `refundFromStaking()`**
   - Description: The `refundFromStaking()` function allows the dispenser contract to record the amount returned from staking to the inflation. However, if the `amount` parameter is extremely large, it could cause an overflow in the `stakingIncentive` calculation, leading to a revert and potentially locking the funds.
   - Recommendation: Consider adding a check to ensure that the sum of `mapEpochStakingPoints[eCounter].stakingIncentive` and `amount` does not exceed `type(uint96).max` before updating the `stakingIncentive` value. If an overflow is detected, make sure to handle the case appropriately, such as reverting the transaction or limiting the refunded amount.
   - Code Snippet:
     ```solidity
     uint256 stakingIncentive = mapEpochStakingPoints[eCounter].stakingIncentive + amount;
     if (stakingIncentive > type(uint96).max) {
         revert Overflow(stakingIncentive, type(uint96).max);
     }
     ```

83. **[Tokenomics.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Tokenomics.sol): Inconsistency in `topUpEligible` calculation**
   - Description: In the `_trackServiceDonations()` function, the `topUpEligible` variable is calculated based on the `veOLASThreshold` value and the `veOLAS` balance of the service owner or donator. There is a potential inconsistency if the `veOLASThreshold` value is updated during the iteration. This could lead to incorrect eligibility determinations for top-ups.
   - Recommendation: Consider storing the `veOLASThreshold` value in a local variable before the iteration starts and using that value consistently throughout the iteration. This ensures that the eligibility determination is based on the same threshold value for all services.
   - Code Snippet:
     ```solidity
     bool topUpEligible;
     if (incentiveFlags[2] || incentiveFlags[3]) {
         address serviceOwner = IToken(serviceRegistry).ownerOf(serviceIds[i]);
         topUpEligible = (IVotingEscrow(ve).getVotes(serviceOwner) >= veOLASThreshold  ||
             IVotingEscrow(ve).getVotes(donator) >= veOLASThreshold) ? true : false;
     }
     ```

84. **[TokenomicsConstants.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/TokenomicsConstants.sol): Duplication of logic in `getSupplyCapForYear()` and `getInflationForYear()` functions**
   - Description: The `getSupplyCapForYear()` and `getInflationForYear()` functions contain similar logic for calculating the supply cap and inflation amount based on the number of years passed. This duplication of logic can make the code harder to maintain and more prone to errors if changes need to be made in the future.
   - Recommendation: Extract the common logic for calculating the supply cap and inflation amount into a separate internal function. This will reduce code duplication, improve maintainability, and make the code more modular.
   - Code Snippet:
     ```solidity
     function getSupplyCapForYear(uint256 numYears) public pure returns (uint256 supplyCap) {
         // ...
         if (numYears < 10) {
             // ...
         } else {
             // ...
         }
     }
     
     function getInflationForYear(uint256 numYears) public pure returns (uint256 inflationAmount) {
         // ...
         if (numYears < 10) {
             // ...
         } else {
             // ...
         }
     }
     ```

85. **[TokenomicsConstants.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/TokenomicsConstants.sol): Magic numbers used in calculations**
   - Description: The `getSupplyCapForYear()` and `getInflationForYear()` functions use magic numbers such as `9`, `10`, and `100` in their calculations. Using magic numbers without clear explanations can make the code less readable and more difficult to understand.
   - Recommendation: Replace magic numbers with named constants or variables that clearly convey their meaning. This will improve code readability and make the intentions behind the calculations more explicit.
   - Code Snippet:
     ```solidity
     function getSupplyCapForYear(uint256 numYears) public pure returns (uint256 supplyCap) {
         // ...
         if (numYears < 10) {
             // ...
         } else {
             numYears -= 9;
             // ...
             supplyCap += (supplyCap * maxMintCapFraction) / 100;
         }
     }
     ```

86. **[TokenomicsConstants.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/TokenomicsConstants.sol): Lack of input validation for `numYears` parameter**
   - Description: The `getSupplyCapForYear()` and `getInflationForYear()` functions do not validate the `numYears` parameter to ensure it falls within a reasonable range. Passing an extremely large value for `numYears` could lead to unnecessary computations.
   - Recommendation: Add input validation checks for the `numYears` parameter to ensure it falls within a reasonable range. You can check if `numYears` is `<=` the maximum expected number of years the contract is intended to support.
   - Code Snippet:
     ```solidity
     function getSupplyCapForYear(uint256 numYears) public pure returns (uint256 supplyCap) {
         require(numYears <= MAX_SUPPORTED_YEARS, "Exceeds maximum supported years");
         // ...
     }
     
     function getInflationForYear(uint256 numYears) public pure returns (uint256 inflationAmount) {
         require(numYears <= MAX_SUPPORTED_YEARS, "Exceeds maximum supported years");
         // ...
     }
     ```

87. **[Dispenser.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Dispenser.sol): Potential race condition in `claimStakingIncentives()`**
   - Description: The `claimStakingIncentives()` function performs multiple external calls to the `Tokenomics` and `VoteWeighting` contracts to calculate staking incentives. If these contracts are upgradeable or can be modified by an external entity, there is a potential race condition where the contract state may change between the external calls.
   - Recommendation: Use a snapshot of the relevant contract states at the beginning of the function to ensure consistency throughout the incentive calculation process. Alternatively, ensure that the external contracts are non-upgradeable and cannot be modified in a way that affects the incentive calculation.
   - Code Snippet:
     ```solidity
     function claimStakingIncentives(
         uint256 numClaimedEpochs,
         uint256 chainId,
         bytes32 stakingTarget,
         bytes memory bridgePayload
     ) external payable {
         // ...
         // Take a snapshot of the relevant contract states
         uint256 snapshotEpochCounter = ITokenomics(tokenomics).epochCounter();
         uint256 snapshotEpochLen = ITokenomics(tokenomics).epochLen();
         // Use the snapshot values for incentive calculation
         // ...
     }
     ```

88. **[Dispenser.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Dispenser.sol): Incorrect error message in `claimStakingIncentives()`**
   - Description: In the `claimStakingIncentives()` function, if the `OLAS` token transfer fails, it reverts with the error message `"ClaimIncentivesFailed"`. However, this error message is misleading as it suggests a failure in claiming incentives, whereas the actual failure is in the token transfer.
   - Recommendation: Update the error message to accurately reflect the nature of the failure, such as `"OLASTransferFailed"` or a more descriptive error message indicating the specific transfer failure.
   - Code Snippet:
     ```solidity
     function claimStakingIncentives(
         uint256 numClaimedEpochs,
         uint256 chainId,
         bytes32 stakingTarget,
         bytes memory bridgePayload
     ) external payable {
         // ...
         // Mint tokens to self in order to distribute to the staking deposit processor
         ITreasury(treasury).withdrawToAccount(address(this), 0, transferAmount);
         
         // Check the balance after the mint
         olasBalance = IToken(olas).balanceOf(address(this)) - olasBalance;
         if (olasBalance != transferAmount) {
             revert OLASTransferFailed(olasBalance, transferAmount);
         }
         // ...
     }
     ```

89. **[Dispenser.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Dispenser.sol): Lack of input validation in `setDepositProcessorChainIds()`**
   - Description: The `setDepositProcessorChainIds()` function allows the contract owner to set deposit processor contract addresses and corresponding chain IDs. However, there is no validation to ensure that the provided chain IDs are unique and non-zero. Setting duplicate or 0` chain IDs can lead to incorrect behavior or overwriting of existing deposit processor addresses.
   - Recommendation: Add input validation to ensure that the provided chain IDs are unique and non-zero before updating the `mapChainIdDepositProcessors` mapping. Revert the transaction if any duplicate or `0` chain IDs are detected.
   - Code Snippet:
     ```solidity
     function setDepositProcessorChainIds(address[] memory depositProcessors, uint256[] memory chainIds) external {
         // ...
         for (uint256 i = 0; i < chainIds.length; ++i) {
             require(chainIds[i] != 0, "Zero chain ID");
             for (uint256 j = i + 1; j < chainIds.length; ++j) {
                 require(chainIds[i] != chainIds[j], "Duplicate chain ID");
             }
             mapChainIdDepositProcessors[chainIds[i]] = depositProcessors[i];
         }
         // ...
     }
     ```

90. **[Dispenser.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Dispenser.sol): Inconsistency in `syncWithheldAmountMaintenance()`**
   - Description: The `syncWithheldAmountMaintenance()` function allows the contract owner to manually sync the withheld amount for a specific chain ID. However, there is no validation to ensure that the provided chain ID corresponds to an existing deposit processor. Syncing the withheld amount for a non-existent chain ID may lead to inconsistent state and incorrect accounting.
   - Recommendation: Add a check to ensure that the provided chain ID has a corresponding deposit processor address set in the `mapChainIdDepositProcessors` mapping before updating the withheld amount. Revert the transaction if the chain ID is invalid or does not have a registered deposit processor.
   - Code Snippet:
     ```solidity
     function syncWithheldAmountMaintenance(uint256 chainId, uint256 amount) external {
         // ...
         require(mapChainIdDepositProcessors[chainId] != address(0), "Invalid chain ID");
         // ...
         mapChainIdWithheldAmounts[chainId] = withheldAmount;
         // ...
     }
     ```

91. **[Dispenser.sol](https://github.com/code-423n4/2024-05-olas/blob/main/tokenomics/contracts/Dispenser.sol): Lack of access control for `retain()` function**
   - Description: The `retain()` function allows anyone to call it and retain staking incentives according to the retainer address. While the function itself does not pose a direct security risk, it may not be intended for public access and could potentially be called by unauthorized entities, leading to unintended behavior or excessive gas consumption.
   - Recommendation: Consider adding access control mechanisms to restrict the access to the `retain()` function to authorized addresses only, such as the contract owner or a specific role. This ensures that only intended parties can trigger the retention of staking incentives.
   - Code Snippet:
     ```solidity
     function retain() external onlyAuthorized {
         // ...
     }
     
     modifier onlyAuthorized() {
         require(msg.sender == owner, "Unauthorized");
         _;
     }
     ```